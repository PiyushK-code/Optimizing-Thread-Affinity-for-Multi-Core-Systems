#include <iostream>
#include <sys/syscall.h>
#include <unistd.h> 
#include <stdlib.h>
#include <map>  
#include <fstream>
#include "work.h"

//core_map is a global variable to store the affinity for each thread as read from the file affinity.txt
std::map<int, int> core_map;

// implement the functions here.
void start_monitoring_for_thread(uint32_t threadIdx, pid_t tid, pthread_t handle) {
	(void)handle;
    //Running the perf stat command to record the stats for each thread	
	std::string command = "perf stat -e cycles,instructions,cache-references,cache-misses,branch-misses,page-faults,L1-dcache-loads,L1-dcache-load-misses,LLC-loads,LLC-load-misses -t " 
                          + std::to_string(tid)+" > perf_thread_"+ std::to_string(threadIdx) + ".txt 2>&1 &";
    	int result=system(command.c_str());
    	
    	if(result==-1)
    		std::cerr<<"Failed to stat perf for thread "<<threadIdx<<std::endl;
	
}

void stop_monitoring_for_thread(uint32_t threadIdx) {
(void)threadIdx;
	//system("pkill -f 'perf stat'");
	//std::cout<<"Stopped monitoring for thread "<<threadIdx<<std::endl;
}

int32_t get_thread_affinity(uint32_t threadIdx) {
    
   //Check if the threadIdx exists in core_map
    auto it = core_map.find(threadIdx);
    if (it != core_map.end()) {
        // Return the associated core ID if found
        return it->second;
    }
    // Return -1 if no specific core is assigned for this thread
    return -1;
}

// Loads affinity settings from the output file affinity.txt generated by analyze.py
std::map<int, int> loadAffinitySettings() {
    std::map<int, int> affinityMap;
    std::ifstream file("affinity.txt");

    if (!file.is_open()) {
        std::cerr << "Error: Could not open affinity.txt file." << std::endl;
        return affinityMap;
    }

    int thread_id, core_id;
    std::string line;
    while (std::getline(file, line)) {
        if (sscanf(line.c_str(), "Thread %d: %d", &thread_id, &core_id) == 2) {
            affinityMap[thread_id] = core_id;
        }
    }

    file.close();
    return affinityMap;
}

int main(int argc, char **argv)
{
  // DO NOT MODIFY THE FOLLOWING BLOCK.
  // =================================================
  if (argc != 2)
  {
    printf("Usage: %s <seed>\n", argv[0]);
    return 1;
  }
  int sr_no = atoi(argv[1]);
  int num_threads = work_init(sr_no);
  // =================================================
  // Modify below this
  
  std::cout << "The number of threads: " << num_threads << std::endl;

  // Modify above this
  // DO NOT MODIFY THE FOLLOWING BLOCK.
  // =================================================
  work_start_monitoring();
  // =================================================
  // Modify below this
  //Running python script, optimum affinity gets written to the file affinity.txt
  sleep(5);
  int result = system("python3 analyze.py");
    if (result != 0) {
        std::cerr << "Error: analyze.py script failed to run." << std::endl;
    }

  // Load affinity settings from affinity.txt
  core_map = loadAffinitySettings();
  	

  // Your code / script for analysis goes here.

  // Modify above this
  // DO NOT MODIFY THE FOLLOWING BLOCK.
  work_run();
  
  // =================================================
  // Modify below this
  

  return 0;
}
